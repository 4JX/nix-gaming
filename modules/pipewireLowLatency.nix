{
  config,
  pkgs,
  lib,
  ...
}: let
  inherit (lib.modules) mkIf;
  inherit (lib.options) mkOption mkEnableOption;
  inherit (lib.types) int;
  inherit (lib.generators) toLua;

  cfg = config.services.pipewire.lowLatency;
  qr = "${toString cfg.quantum}/${toString cfg.rate}";
in {
  # low-latency PipeWire configuration
  # extends the nixpkgs module
  meta.maintainers = with lib.maintainers; [fufexan];

  options = {
    services.pipewire.lowLatency = {
      enable = mkEnableOption ''
        low latency for PipeWire. This will also set `services.pipewire.enable` and
        `services.pipewire.wireplumber.enable` to true.
      '';

      quantum = mkOption {
        description = "Minimum quantum to set";
        type = int;
        default = 64;
        example = 32;
      };

      rate = mkOption {
        description = "Rate to set";
        type = int;
        default = 48000;
        example = 96000;
      };
    };
  };

  config = mkIf cfg.enable {
    services.pipewire = {
      # make sure PipeWire is enabled if the module is imported
      # and low latency is enabledd
      enable = true;

      # write extra config
      extraConfig = {
        pipewire."99-lowlatency" = {
          "context.properties" = {
            "default.clock.min-quantum" = cfg.quantum;
          };

          "context.modules" = [
            {
              name = "libpipewire-module-rt";
              args = {
                "nice.level" = -15;
                "rt.prio" = 88;
                "rt.time.soft" = 200000;
                "rt.time.hard" = 200000;
              };
            }
          ];
        };

        pipewire-pulse."99-lowlatency" = {
          "context.modules" = [
            {name = "libpipewire-module-protocol-pulse";}
          ];

          "pulse.properties" = {
            "server.address" = ["unix:native"];
            "pulse.min.req" = qr;
            "pulse.min.quantum" = qr;
            "pulse.min.frag" = qr;
          };
        };

        client."99-lowlatency" = {
          "stream.properties" = {
            "node.latency" = qr;
            "resample.quality" = 1;
          };
        };
      };

      # ensure WirePlumber is enabled explicitly (defaults to true while PW is enabled)
      # and write extra config to ship low latency rules for alsa
      wireplumber = {
        enable = true;
        configPackages = let
          # generate "matches" section of the rules
          matches = toLua {
            multiline = false; # looks better while inline
            indent = false;
          } [[["node.name" "matches" "alsa_output.*"]]]; # nested lists are to produce `{{{ }}}` in the output

          # generate "apply_properties" section of the rules
          apply_properties = toLua {} {
            "audio.format" = "S32LE";
            "audio.rate" = cfg.rate * 2;
            "api.alsa.period-size" = 2;
          };
        in [
          (pkgs.writeTextDir "share/lowlatency.lua.d/99-alsa-lowlatency.lua" ''
            -- Generated by nix-gaming
            alsa_monitor.rules = {
              {
                matches = ${matches};
                apply_properties = ${apply_properties};
              }
            }
          '')
        ];
      };
    };
  };
}
